# 数据结构

[toc]

## 第一章 绪论

------

### 1.1 数据结构的基本概念

#### 1.1.1 基本概念和术语

1. 数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机识别和处理的符号的集合。
2. 数据元素：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
3. 数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。
4. 数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称。
   - 原子类型：其值不可再分的数据类型。
   - 结构类型：其值可以在分解为若干成分的数据类型。
   - 抽象数据类型：抽象数据组织及与之相关的操作。
5. 数据结构：数据结构是相互之间存在一种或多种特定关系的数据元素的集合，包括：逻辑结构、存储结构和数据的运算。

#### 1.1.2 数据结构三要素

1. 数据的逻辑结构

   逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。

   - 集合：结构中的数据元素之间除“同属一个集合”外，再无其他关系。
   - 线性结构：结构中的数据元素之间存在一对一的关系。
     - 一般线性表
     - 受限线性表
       - 栈
       - 队列
       - 串
     - 数组
   - 非线性结构：结构中的数据元素之间存在一对多，多对多的关系。
     - 集合
     - 树形结构
       - 一般树
       - 二叉树
     - 图状结构
       - 有向图
       - 无向图

2. 数据的存储结构

   存储结构是指数据在计算机中的表示，又称映像，也称物理结构。

   - 顺序存储：逻辑上相邻的元素物理位置上也相邻。
     - 优点：可以随机存取，时间复杂度O(1)。
     - 缺点:   只能使用一整块存储单元，会存在较多的外部碎片。
   - 链式存储：不要求逻辑上相邻的元素物理位置上也想领，借助指针来表示元素之间的关系。
     - 优点：不会出现碎片现象，能充分利用所有存储单元。
     - 缺点：需要额外空间来存放指针，且只能顺序存取。
   - 索引存储：在存储元素信息的同时，还建立附加的索引表。
     - 优点：检索速度快；
     - 缺点：索引表需要占用额外的空间，修改删除数据时，也要更新索引表。
   - 散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。
     - 优点：检索、增加和删除结点的操作都很快。
     - 缺点：散列函数不好的话，则可能出现哈希冲突。

3. 数据的运算

   是加载数据上的运算包括运算的定义（针对逻辑结构）和实现（针对存储结构）。

------

### 1.2 算法和算法的评价

#### 1.2.1 算法的基本概念

> 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作

算法的重要特性：

1. 有穷性：算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性：算法中每条指令都必须有明确的含义，对于相同的输入能够得到相同的输出。
3. 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。
5. 输出：一个算法有一个或多个输出，这些输出是与输入有某种特定关系的量。

一个好算法的目标：

1. 正确性：算法应该能够正确的解决求解问题。
2. 可读性：算法应该具有良好的可读性，以帮助人们理解。
3. 健壮性：输入非法数据时，算法能适当的做出反应或进行处理，而不是产生莫名其妙的输出。
4. 高效率和低存储量需求：低时间复杂度，低空间复杂度。

#### 1.2.2 算法效率的度量

1. 时间复杂度

   常见时间复杂度

   $O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$

2. 空间复杂度

------

## 第二章 线性表

### 2.1 线性表的定义和基本操作

#### 2.1.1 线性表的定义

> 线性表是具有相同数据类型的n（n>0）个数据元素的有限序列，其中n为表长，当n = 0时，线性表是一个空表。若用L命名线性表，则其一般表示为：$L=(a_1,a_2,…,a_i,a_{i+1},…,a_n)$。式中，$a_1$是唯一一个“第一个”元素，又称表头元素；$a_n$是唯一一个“最后一个”数据元素，又称表尾元素。除第一个元素外，每个元素有且只有一个直接前驱；除最后一个元素外，每个元素有且只有一个直接后继。

#### 2.1.2 线性表的基本操作

> 一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。

1. InitList(&L)：初始化线性表。
2. Length(&L)：返回线性表的长度。
3. LocateElem(&L,e)：根据给定值查找线性表元素。
4. GetElem(&L,i)：根据下表查找线性表元素。
5. ListInsert(&L,i,e)：在线性表给定位置插入数据元素。
6. ListDelete(&L,i,&e)：删除线性表给定位置的元素，并返回值。
7. PrintList(&L)：打印线性表所有元素。
8. Empty(&L)：判断线性表是否为空。
9. DestoryList(&L)：销毁线性表。

###  2.2 线性表的顺序表示

####  2.2.1 顺序表的定义

> 线性表的顺序存储又称**顺序表**，由一组连续的地址空间存储元素，顺序表中的位序是从1开始，数组下标是从0开始。

顺序表的特点：

- 随机访问，即通过首地址和元素序号可在O(1)的时间复杂度内找到制定元素。
- 存储密度高，每个结点只存储元素。
- 逻辑上相邻的元素物理上也相邻，所以插入和删除元素需要移动大量的元素。

####  2.2.2 顺序表上基本操作的实现

1. 插入操作
   - 最好情况：在表尾插入，不用移动元素，时间复杂度O(1)。
   - 最坏情况：在表头插入，移动语句需要执行n次，时间复杂度O(n)。
   - 平均情况：O(n)。
2. 删除操作
   - 最好情况：删除表尾，不用移动元素，时间复杂度O(1)。
   - 最坏情况：删除表头，需要移动除表头外所有元素，时间复杂度O(n)。
   - 平均情况：O(n)。
3. 按值查找
   - 最好情况：在表头，比较一次，时间复杂度O(1)。
   - 最坏情况：在表尾或不存在，需要比较n次，时间复杂度O(n)。
   - 平均情况：O(n)。

###  2.3 线性表的链式表示

####  2.3.1 单链表的定义

> 线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。每个结点除了数据域外，还有指向下一个结点的指针域。

单链表的特点：

- 非随机访问，要按序号访问结点，需要从头遍历一遍单链表。
- 存储密度低，每个结点需要额外存储下一个结点的指针。
- 不需要连续的存储空间，逻辑上相邻的元素物理上不一定相邻，所以删除插入不需要移动元素，时间复杂度O(1)。

####  2.3.2 单链表上基本操作的实现

1. 采用头插法建立单链表

   > 每次插入结点都在头结点（指针）后面插入，链表顺序和输入顺序相反。

   - 时间复杂度：O(n)。

2. 采用尾插法建立单链表

   > 每次插入结点都在表尾插入，可新增一个尾指针，链表顺序和输入顺序相同。

   - 时间复杂度：O(n)。

3. 按序号查找结点

   - 时间复杂度：O(n)。

4. 按值查找结点

   - 时间复杂度：O(n)。

5. 插入结点操作

   > 前插操作可以改为后插操作，然后交换数据域的值。

   - 时间复杂度：O(n)

     本身插入操作复杂度是O(1)，但查找前驱结点复杂度为O(n)。

6. 删除结点操作

   > 删除给定结点P可以改为先将P后继结点数据域值付给P，之后删除其后继结点，这样就不用查找前驱结点。

   - 时间复杂度：O(n)，同上。

7. 求表长

   - 时间复杂度：O(n)。

####  2.3.3 双链表

> 在单链表结点后继指针的基础上，加上前驱指针

双链表特点：不用查找结点的前驱指针，因此插入、删除操作时间复杂度为O(1)。

#### 2.3.4 循环链表

1. 循环单链表

   单链表尾结点的后继指针指向头结点，特点：

   - 判空条件为头结点指针是否为头指针。
   - 在任意位置上插入、删除的操作都是等价的，无需判断是否是表尾。
   - 可以在链表任意位置开始遍历链表。
   - 若仅设尾指针，则在表头或表尾插入元素都只需O(1)时间复杂度。

2. 循环双链表

   双链表头结点的前驱指针指向尾结点，尾结点的后继指针指向头结点，特点：

   - 判空条件为头结点的前驱和后继指针都是头指针。

#### 2.3.5 静态链表

> 用数组来描述线性表的链式存储结构，结点也有数据域和指针域，不过指针是结点的相对位置（数组下标），又称游标。和顺序表一样，需要连续的存储空间。

##  第三章 栈、队列和数组

### 3.1 栈

#### 3.1.1 栈的基本概念

1. 栈的定义：只允许在一端进行插入和删除操作的线性表。
   - 有n个不同的元素入栈，出栈序列有 ${1 \over n+1}{C_{2n}^{n}}$种

2. 栈的基本操作
   - 初始化栈：InitStack(&S);
   - 栈判空：StackEmpty(&S);
   - 入栈：Push(&S,x );
   - 出栈：Pop(&S,&x);
   - 获取栈顶元素：GetTop(&S);
   - 销毁栈：DestoryStack(&S);


#### 3.1.2 栈的顺序结构

1. 顺序栈的实现
   - 栈顶指针：S.top, 初始时设置S.top = -1;
   - 栈顶元素：S.data[S.top];
   - 进栈操作：栈不满时，S.top+1, S.data[S.top] = x;
   - 出栈操作：栈不空时，x = S.data[S.top], S.top - 1;
   - 栈空条件：S.top == -1;
   - 栈满条件：S.top == MaxSize - 1;
2. 顺序栈的基本运算
3. 共享栈
   - 判空条件：top1 = -1, top2 = MaxSize
   - 栈满条件：top2 - top1 = 1

#### 3.1.3 栈的链式存储结构

特点：可多个栈共享存储空间，不会发生栈满上溢的情况。

### 3.2 队列

#### 3.2.1 队列的基本概念

1. 队列的定义：队列，简称队，是指在一端进行输入，在另一端输出的线性表
   - 特性：先进先出（FIFO, First In First out）。
   - 队头：允许输出的一端。
   - 队尾：允许输入的一端。
2. 队列的基本操作
   - 初始化队列：InitQueue(&Q);
   - 入队：EnQueue(&Q, x);
   - 出队：DeQueue(&Q);
   - 打印队头元素：GetHead(&Q)
   - 判空：EmptyQueue(&Q);

#### 3.2.2 队列的顺序存储结构

1. 队列的顺序存储：分配一块连续的空间用来存放队列中的元素，并附两个指针，队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。
   - 初始时：Q.front = Q.rear = 0；
   - 进队操作：队不满，把值放入队尾指针位置，队尾指针再加一；
   - 出队操作：队不空，先取队头元素，队头指针再加一；
2. 循环队列：将顺序队列臆造为一个环状空间，把顺序表逻辑上视为一个环，称为循环队列。
   - 初始时：Q.front = Q.rear = 0；
   - 队首指针进1：Q.front = (Q.front + 1) % MaxSize；
   - 队尾指针进1：Q.rear = (Q.rear + 1) % MaxSize；
   - 队列长度：(Q.rear - Q.front + MaxSize) % MaxSize；

#### 3.2.3 队列的链式存储结构

> 队列的链式存储：实际上是一个同时带有队头指针和队尾指针的单链表。

#### 3.2.4 双端队列

- 不受限的双端队列：两端都可进行入队、出队操作；
- 输出受限的双端队列：一端允许入队、出队，另一端只允许入队；
- 输入受限的双端队列：一端允许入队、出队，另一端只允许出队；

### 3.3  栈和队列的应用

#### 3.3.1 栈在括号匹配中的应用

[ 	( 	[ 	] 	{ 	} 	) 	]

#### 3.3.2 栈在表达式求值中的应用

A + B * ( C - D ) - E / F的后缀表达式为：ABCD-*+EF/-

- 不同操作符，乘除大于加减
- 同一操作符，栈内数大于栈外数
- 栈内数大，栈内推栈并输出；栈外数大，直接入栈

| 操作符 | #    | (    | *,/  | +,-  | )    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| isp    | 0    | 1    | 5    | 3    | 6    |
| icp    | 0    | 6    | 4    | 2    | 1    |

#### 3.3.3 栈在递归中的应用

在一个函数、过程或数据结构中的定义中又应用了他自身，则这个函数、过程或数据结构称为递归，递归条件：

1. 递归表达式
2. 边界条件

递归效率低的原因：存在重复计算。

#### 3.3.4 队列在层次遍历中的应用

1. 根结点入队；
2. 若队空（所有节点处理完），则结束，否则重复3操作；
3. 队列中第一个结点出队，并访问之，若其有左孩子，则左孩子入队；若其有右孩子，则右孩子入队。

#### 3.3.5 队列在计算机系统中的应用

- 解决主机与外部设备之间速度不匹配的问题。
- 解决由多用户引起的资源竞争问题

## 第四章 串

### 4.1 串的定义和实现

#### 4.1.1 串的定义

**串**（字符串）是由零个或多个字符组成的有限序列。一般记为：$S = 'a_1a_2...a_n'（n \neq 0）$。其中，S是串名，单引号扩起来的是串的值。$a_i$可以是字母、数字或其他字符；串中字符的个数称为串的长度。n=0时串称为空串。

- 子串：串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。
- 子串的位置：子串在主串中的位置以子串的第一个字符在主串中的位置来表示。

#### 4.1.2 串的存储结构

1. 定长顺序存储表示

   ```c
   #define MAXLEN 255
   typedef struct{
   	char ch[MAXLEN];
     int length;
   }SString
   ```

   串长的表示方法：

   - 用额外变量len来存放串的长度
   - 在串值后面加一个不计入串长的结束标记字符"\0"

2. 堆分配存储表示

   ```c
   typedef struct{
   	char *ch;
     int length;
   }HString
   ```

### 4.1.3 串的基本操作

- StrAssign(&T, chars)：赋值操作。
- StrCopy(&T, S)：复制操作。
- StrEmpty(&T)：判空操作。
- StrCompare(S, T)：比较操作。
- StrLength(&T)：求串长。
- Concat(&T, S1, S2)：串联接。
- Index(S, T)：定位操作。
- ClearString(&S)：清空操作。
- DestoryString(&S)：销毁串。

### 4.2 串的模式匹配

#### 4.2.1 简单的模式匹配算法

时间复杂度：O(mn)

```java
public int index(String mainString, String subString){
  int i,j = 1;
  while(i <= mainString.length && j <= subString.length){
    if(mainString.toCharArray()[i] == subString.toCharArray()[j]){
      i++;
      j++;
    }
    else{
      i = i - j + 2;
      j = 1;
    }
  }
  if(j > subString.length) return i - subString.length;
  return 0;
}
```

#### 4.2.2 串的模式匹配算法--KMP算法

时间复杂度：O(m + n)

1. 字符串的前缀、后缀和部分匹配值

   - 前缀：指除最后一个字符意外，字符串的所有头部子串。
   - 后缀：指除第一个字符外，字符串的所有尾部子串。
   - 部分匹配值：为字符串的前缀和后缀的最长相等前后缀长度。

   例如：字符串ababa的部分匹配值为00123，其部分匹配值（Partial Match, PM）表如下：

   | 编号 | 1    | 2    | 3    | 4    | 5    |
   | ---- | ---- | ---- | ---- | ---- | ---- |
   | S    | a    | b    | a    | b    | a    |
   | PM   | 0    | 0    | 1    | 2    | 3    |

   当发现子串当前匹配字符与主串字符不匹配时，子串需要向后移动的位数为：

   移动位数 = 已匹配的字符数 - 对应的部分匹配值

2. 优化KMP算法

   已知：右移位数 = 已匹配的字符数 - 对应的部分匹配值

   写成：$Move = ( j - 1 ) - PM[j - 1]$（j为当前子串匹配的字符下标）

   - 将PM表右移一位，得到next数组：

     | 编号 | 1    | 2    | 3    | 4    | 5    |
     | ---- | ---- | ---- | ---- | ---- | ---- |
     | S    | a    | b    | a    | b    | a    |
     | next | -1   | 0    | 0    | 1    | 2    |

     - 第一个元素右移之后用-1来填充，因为第一个若第一个元素匹配失败，则直接右移一位，不需要计算。
     - 最后一个元素右移之后移出，因为原来子串中，最后一位元素的部分匹配值是下一个元素使用的，但已经没有下一个元素，故可舍去。

   - 得到：$Move = ( j - 1) - next[ j ]$

     相当于子串的比较指针j回退到：$j = j -Move = j - ( j - 1) - next[ j ] = next[j] + 1$

     则将next数组整体加一得到：

     | 编号 | 1    | 2    | 3    | 4    | 5    |
     | ---- | ---- | ---- | ---- | ---- | ---- |
     | S    | a    | b    | a    | b    | a    |
     | next | 0    | 1    | 1    | 2    | 3    |

   - 得到指针变换公式：$j = next[j]$

     即：在子串的第j个字符与主串发生失配时，则跳到子串的next[ j ]位置与主串当前位置进行比较。

   - 更一般的：
     $$
     next[j] = 
     \begin{cases}
     0, & \text{j = 1}\\
     max\{k|1 \lt k \lt j且'{p_1}...'{p_{k-1}} = {p_{j-k+1}}...{p_{j-1}} \}, & \text{当此集合不空} \\
     1, & \text{其他情况}
     \end{cases}
     $$
     $若next[j] = k，则next[j + 1]为$：

     - 若$p_k = p_j$，则$next[j + 1] = next[j] + 1$；
     - 若$p_k \neq p_j$，则找到$k' = next[next...[k]] (1 < k' < k < j)$，$next[j +1] = k' + 1$。

#### 4.2.3 KMP算法的进一步优化

优化原因：next数组中不应出现$p_j = p_{next[j]}$，若$p_j$与$s_j$匹配失败，用pnext[j]与sj匹配则必然失败，应继续递归知道出现$p_j \neq p_{next[next[j]]}$。则得到nextval数组：

| 编号    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| S       | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |
| next    | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    | 5    | 6    |
| nextval | 0    | 1    | 0    | 1    | 0    | 4    | 2    | 1    | 0    | 1    | 0    | 4    |

## 第五章 树与二叉树

### 5.1 树的基本概念

#### 5.1.1 树的定义

树时n（n $\geq$ 0）个结点的有限集合。当n=0时，称为空树。任意一棵非空树应满足

- 有且仅有一个根结点。
- 当n > 1时，其余结点可分为m（m > 0）个互不相交的有限集$T_1,T_2,...,T_m$，其中每个集合本身又是一颗树，并且称为树的子树。

树的特点：

- 除跟结点外，所有结点有且只有一个前驱。
- 树中所有结点都有零个或多个后继。

#### 5.1.2 基本术语

- 结点的度：指树中一个结点的孩子个数。
- 树的度：指树中结点最大的度数。
- 分枝结点（非终端结点）：指树中度大于零的结点。
- 叶结点（终端结点）：指树中度为零的结点。
- 结点的层次：根结点为第一层，其子结点为第二层，以此类推。
- 结点的深度：由根结点开始自顶向下逐层累加。
- 结点的高度：由叶结点开始自底向上逐层累加。
- 树的高度（深度）：树中结点的最大层树。
- 有序树：树中结点的各子树从左到右是有次序的，若交换左右子树顺序，则变成一棵新树。
- 无序树：树中结点的各子树从左到右无序，交换子树顺序不会产生一棵新树。
- 路径（从上到下）：树中两个结点之间的路径是由两个结点之间所经过的结点序列构成。兄弟之间不存在路径。
- 路径长度：指路径上所经历的边的个数。

#### 5.1.3 树的性质

- 树中的结点数等于度数数之和+1。
- 度为m的数中第i层上至多有$m^{i-1}$个结点（$i\ge1$）。
- 高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点。

具有m个结点的m叉树的最小高度为$\lceil{log_m(n(m-1)+1)}\rceil$。

### 5.2 二叉树的概念

#### 5.2.1 二叉树的定义及其主要特性

1. 二叉树的定义

   二叉树是n（$n\geq0$）个结点的有限集合：

   - 或者为空二叉树，即n = 0。
   - 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树。

2. 几个特殊的二叉树

   - 满二叉树：一颗高度为h，却含有$2^h-1$个结点的二叉树。对于编号为i的结点：
     - 若有双亲，则其双亲为$\lfloor i/2 \rfloor$。
     - 若有左孩子，则左孩子为2i。
     - 若有右孩子，则右孩子为2i + 1。
   - 完全二叉树：高度为h，有n个结点，且其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应。对于完全二叉树：
     - 若$i \leq \lfloor n/2 \rfloor$，则结点i为分枝结点，否则为叶结点。
     - 叶结点只可能在层次最大的两层上出现。对于最大层次的叶结点，都一次排列在该层最左侧。
     - 若有度为1的结点，则只可能有一个，且该结点只有左孩子五右孩子。（重要特性）
     - 按层序编号后，一旦出现某结点为叶结点或只有左孩子，则编号大于i的结点均为叶结点。
     - 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分枝结点（编号为n\2）只有左孩子，没有右孩子，其余分枝结点左、右孩子都有。
   - 二叉排序树：左子树上所有结点的关键字均小于跟结点的关键字；右子树上的关键字均大于根结点的关键字；左子树和右子树又各是一颗二叉排序树。
   - 平衡二叉树：树上任意一个结点的左子树和右子树深度之差不超过1.

3. 二叉树的性质

   - 非空二叉树上的叶结点树等于度为2的结点数加1，$即n_0 = n_2 + 1。$
   - 非空二叉树第k层上至多有$2^{k-1}$个结点。
   - 高度为h的非空二叉树，至多有$2^k-1$个结点。
   - 对完全二叉树按照从上到下、从左到右编号，1,2,3,...,n，则有以下关系：
     - 当$i >1$时，结点$i$的双亲编号为$\lfloor i/2 \rfloor$，即，当$i为偶数时$，其双亲编号为$i/2$，它为双亲的左孩子；当$i为奇数时$，其双亲编号为$(i-1)/2$，它是双亲的右孩子。
     - 当$2i \le n$时，结点$i$的左孩子编号为2$i$，否则无左孩子。
     - 当$2i+1 \le n时$，结点$i$的右孩子编号为$2i+1$，否则无右孩子。
     - 结点$i$所在的深度为$\lceil log_2i \rceil + 1$。
   - 具有n个($n \gt0$)结点的完全二叉树的高度为$\lceil log_2(n+1)\rceil$或$\lfloor log_2n \rfloor +1$。

#### 5.2.2 二叉树的存储结构

1. 顺序存储结构

   指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为$i$的结点元素存储在一维数组下标为$i-1$的分量中。

   - 优点：若是完全二叉树或者满二叉树，树中结点的序号可以唯一反应结点之间的逻辑关系，既能最大可能的节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。
   - 缺点：对一一般二叉树，为了让数组下标能反应二叉树中结点之间的关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树的结点一一对应。最坏情况下，一个高度为$h$且只有$h$个结点的单枝树却需要占据近$2^h-1$个存储单位。

2. 链式存储结构

   ```c
   typedef struct BiTNode{
     ElemType data;  //数据域
     struct BiTNode *lchild, *rchild //左、右孩子指针
   }BiTNode, *BiTree;
   ```

   在含有n个结点的二叉链表中，含有$n+1$个空链域。

### 5.3 二叉树的遍历与线索二叉树

#### 5.3.1 二叉树的遍历

1. 先序遍历（PreOrder）

   ```c
   void PreOrder(BiTree T){
     if(T != null){
       visit(T);							// 访问根结点
       PreOrder(T->lchild);	// 递归遍历左子树
       PreOrder(T->rchild);	// 递归遍历右子树
     }
   }
   ```

2. 中序遍历（InOrder）

   ```c
   void InOrder(BiTree T){
     if(T != null){
       InOrder(T->lchild);	// 递归遍历左子树
       visit(T);						// 访问根结点
       InOrder(T->rchild);	// 递归遍历右子树
     }
   }
   ```

3. 后序遍历（PostOrder）

   ```c
   void InOrder(BiTree T){
     if(T != null){
       InOrder(T->lchild);	// 递归遍历左子树
       InOrder(T->rchild);	// 递归遍历右子树
       visit(T);						// 访问根结点
     }
   }
   ```

4. 借用栈可将树的递归遍历转换为非递归遍历，借用队列可实现树的层次遍历。

5. 树的先序序列与先序序列（后序序列/层次遍历）可唯一确定一颗二叉树。

#### 5.3.2 线索二叉树

在二叉树的链式表示中，规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。

```c
typedef struct ThreadNode{
  ElemType data;											//数据元素
  struct ThreadNode *lchild, *rchild;	//左、右孩子指针
  int ltag, rtag;											//左、右线索标志
}ThreadNode, *ThreadTree;
```

### 5.4 树、森林

#### 5.4.1 树的存储结构

1. 双亲表示法

   指用一组连续的空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。

   ```c
   #define MAX_TREE_SIZE 100
   typedef struct{
     ElemType data;
     int parent;
   }PTNode;
   
   typedef struct{
     PTNode nodes[MAX_TREE_SIZE];
     int n;
   }PTree;
   ```

   优点：可以快速得到每个结点的双亲结点。

   缺点：求结点的孩子时，需要遍历整个结构。

2. 孩子表示法

   指将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表。

   优点：寻找子女的操作非常直接。

   缺点：求双亲结点时需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。

3. 孩子兄弟表示法

   又称为二叉树表示法，即以二叉链表作为树的存储结构，左指针指向第一个孩子，有指针指向下一个兄弟结点（左孩子，右兄弟）

   ```c
   typedef struct CSNode{
     ElemType data;
     struct CSNode *firstchild, *nextsibling // 第一个孩子和右兄弟指针
   }CSNode, *CSTree;
   ```

   优点：可以方便实现树与二叉树转换，易于查找结点的孩子；

   缺点：查找双亲比较麻烦，若多设置一个指针域指向其父结点，则查找父结点也很方便。

#### 5.4.2 树、森林与二叉树的转换

1. 树与二叉树转换：每个结点的左指针指向它的第一个孩子，右指针指向它在树中相邻的兄弟结点（孩子兄弟表示法）。
2. 森林与二叉树转换：现将森林中每颗树转换为二叉树，每颗树的根也可视为兄弟关系，在每颗树的根之间加一根连线。

#### 5.4.3 树和森林的遍历

- 树的遍历
  - 先根遍历：序列与对应二叉树的先序序列相同。
  - 后根遍历：序列与对应二叉树的中序序列相同。
- 森林的遍历
  - 先序遍历：
    - 访问森林中第一颗树的根结点。
    - 先序遍历第一颗树中根结点的子树森林。
    - 先序遍历除去第一颗树之后剩余的树构成的森林。
  - 中序遍历：
    - 中序遍历第一颗树中根结点的子树森林。
    - 访问第一颗树的根结点。
    - 中序遍历除去第一颗树之后剩余的树构成的森林。

| 树       | 森林     | 二叉树   |
| -------- | -------- | -------- |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |



### 5.5 树与二叉树的应用

#### 5.5.1 哈夫曼树与哈夫曼编码

- 哈夫曼树的定义
  - 带全路径长度：$WPL=\sum_{i=1}^nw_il_i$，$w_i$是第$i$个结点所带的权值，$l_i$是叶结点到根结点的路径长度。
  - 哈夫曼树：指在含有n个带权叶结点的二叉树中，带权路径长度（WPL）最小的二叉树，也称最优二叉树。
- 哈夫曼编码（构造哈夫曼树）
  - 固定长度编码：对每个字符用相等长度的二进制位表示。
  - 可变长度编码：允许对不同字符用不等长的二进制位表示。
  - 前缀编码：没有一个编码是另一个编码的前缀。

#### 5.5.2 并查集

一种简单的集合表示，支持以下三种操作：

- Initial(S)：将集合S中的每个元素都初始化为只有一个单元素的子集合。
- Union(S, Root1, Root2)：把集合S中的子集合Root2并入子集合Root1中，要求两集合互不相交，否则不执行合并。
- Find(S, x)：查找集合S中单元素x所在的子集合，并返回该子集合的根结点。

## 第六章 图

### 6.1 图的基本概念

#### 6.1.1 图的定义

图G是由顶点集V和边集E组成，记为G = (V,E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若$V=\{ v_1,v_2,...,v_n \}$，则用|V|表示图G中顶点的个数，$E = \{ (u,v)|u\in V,v\in V \}$，用|E|表示图G中边的条数。

基本概念：

- 有向图：若E是有向边（也称弧）的有限集合时，则图G为有向图。
- 无向图：若E是无向边（简称边）的有限集合时，则图G为无向图。
- 简单图：数据结构中仅讨论简单图。
  - 不存在重复边
  - 不存在顶点到自身的边
- 多重图：
  - 存在某两个顶点之间的边数大于一 
  - 允许顶点通过一条边和自身关联
- 完全图（简单完全图）：
  - 对于无向图，｜E｜的取值介于0～n(n-1)/2，有n(n-1)/2条边的无向图称为无向完全图。
  - 对于有向图，｜E｜的取值介于0～n(n-1)，有n(n-1)条边的有向图称为有向完全图。
- 子图：设有两个图G = (V,E)和G' = (V',E')，若V'是V的子集，且E'是E的子集，则称G'是G的子图。
- 生成子图：若有满足V(G') = V(G)的子图G'，则称其为G的生成子图。
- 连通、连通图和连通分量：
  - 连通：**无向图**中，若从顶点v到顶点w有路径存在，则称v和w是连通的。
  - 连通图：**无向图**中，若任意两个顶点都是连通的，则称图为连通图。
  - 连通分量：**无向图**中的极大连通子图。
- 强连通、强连通图和强连通分量：
  - 强连通：**有向图**中，若有一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点时强连通的。
  - 强连通图：**有向图中**，若任意两个顶点都是强连通的，则称图为强连通图。
  - 强连通分量：**有向图**中的极大强连通子图。
- 顶点的度、入度和出度：
  - 度：**无向图中**，顶点v的度是指依附于顶点v的边的条数，记为$TD(v)$。
    - 对于有n个顶点，e条边的无向图，$\sum_{i=1}^nTD(v_i)=2e$，即无向图的全部顶点的度之和，等于边数的2倍。
  - 入度和出度：有向图中顶点的度分为入度和出度。
    - 入度：以顶点为终点的有向边的数目，记为$ID(v)$。
    - 出度：以顶点为起点的有向边的数目，记为$OD(v)$。
    - **有向图**顶点的度等于入度加出度：$TD(v)=ID(v)+OD(v)$
    - 对于有n个顶点，e条边的有向图，$\sum_{i=1}^nOD(v_i)=\sum_{i=1}^nID(v_i)=e$，即有向图的全部顶点的入度之和与出度之和相等且等于边数。
- 边的权和网：
  - 权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。
  - 网：边上带有权值的图称为带权图，也称网。
- 稠密图和稀疏图：边数很少的图称为稀疏图，反之称为稠密图。一般满足｜E｜< ｜V｜log｜V｜时，可视为稀疏图。
- 路径、路径长度和回路：
  - 路径：顶点$v_p到顶点v_q之间的一条路径是指顶点序列v_p,v_{i_1},v_{i_2},...,v_{i_m},v_q$。
  - 路径长度：路径上边的数目称为路径长度。
  - 回路：第一个顶点和最后一个顶点相同的路径。
  - 若一个图有n个顶点，并且有大于n-1条边，则此图一定有环。
- 简单路径、简单回路：
  - 简单路径：路径序列中，没有重复出现的顶点。
  - 简单回路：除第一个和最后一个顶点，其余顶点不重复出现的回路。
- 距离：从顶点u出发到顶点v的最短路径若存在，则此路径长度称为u到v的距离。
- 有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树。

### 6.2 图的存储及基本操作

#### 6.2.1 邻接矩阵法

$结点数为n的图G=(V,E)的领结矩阵A是n*n的。将G的顶点编号为v_1,v_2,...,v_n。若(v_i,v_j)\in E，则A[i][j]=1，否则A[i][j]=0。$
$$
A[i][j] = 
\begin{cases}
0, &  若(v_i,v_j)或<v_i,v_j>不是E(G)中的边\\
1, & 若(v_i,v_j)或<v_i,v_j>是E(G)中的边
\end{cases}
$$
对于带权图而言，领结矩阵中对应项存放着该边对应的权值：
$$
A[i][j] = 
\begin{cases}0或\infty, &  若(v_i,v_j)或<v_i,v_j>不是E(G)中的边\\
w_{ij}, & 若(v_i,v_j)或<v_i,v_j>是E(G)中的边
\end{cases}
$$

- 存储结构定义：

  ```c
  #define MaxVertexNum 100
  typedef char VertexType;//顶点数目最大值
  typedef int EdgeType;//顶点数据类型
  typedef struct{
    VertexType Vex[MaxVertexNum];//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];//邻接矩阵，边表
    int vexnum,arcnum;//图当前顶点数和弧数
  }MGraph;
  ```

  

- 特点：

  - 无向图的邻接矩阵是一个对称矩阵且唯一。

  - 对于无向图，邻接矩阵第$i$行（列）非零元素的个数正好是顶点$i$的度$TD(v_i)$。

  - 对于有向图：
    - 邻接矩阵第$i$行非零元素的个数正好是顶点$i$的出度$OD(v_i)$；
    - 邻接矩阵第$i$列非零元素的个数正好是顶点$i$的入度$ID(v_i)$；

  - 容易确定两个顶点之间是否有边相连；确定有多少条边需要按行、列检索，开销较大。

  - 稠密图适合用邻接矩阵。

  - 设图$G$的邻接矩阵为$A,A^n的元素A^n[i][j]$等于顶点$i到顶点j$的长度为n的路径数量。

#### 6.2.2 邻接表法

指对图G中每个顶点$v_i$建立一个单链表，第$i$个单链表中的结点表示依附于顶点$v_i$的边，称为顶点$v_i$的边表。

- 存储结构定义：

  ```c
  #define MaxVertexNum 100
  typedef struct ArcNode{//边表结点
    int adjvex;//该弧所指向的顶点的位置
    struct ArcNode *next;//指向下一条弧的指针
    //InfoType info 网的边权值
  }ArcNode;
  
  typedef struct VNode{//顶点表结点
    VertexType data;//顶点信息
    ArcNode *first;//指向第一条依附于该顶点的弧的指针
  }VNode,AdjList[MaxVertexNum];
  
  typedef struct{
    AdjList vertices;//邻接表
    int vexnum,arcnum;//图的顶点数和弧数
  }ALGraph;
  ```

- 特点：

  - 存储空间：
    - 对于无向图，所需的存储空间为$O(|V|+2|E|)$；
    - 对于有向图，所需存储空间为$O(|V|+|E|)$；
  - 稀疏图适合用邻接表法。
  - 容易找到给定顶点的所有邻边，确定两个顶点是否存在边则需要在相应顶点的边表中查询，开销较大。
  - 有向图中，求给定顶点的出度只需计算其邻接表中的结点个数；求入度则需要遍历全部邻接表。
  - 图的邻接表表示不唯一。

#### 6.2.3 十字链表

十字链表是**有向图**的一种链式存储结构，结构如下：

- 弧结点：

  | Tailvex  | headvex  |         hlink          |         tlink          |   (info)   |
  | -------- | :------: | :--------------------: | :--------------------: | :--------: |
  | 弧尾顶点 | 弧头顶点 | 弧头相同的下一个弧结点 | 弧尾相同的下一个弧结点 | 弧相关信息 |

- 顶点结点：

  |   data   |           firstin            |           firstout           |
  | :------: | :--------------------------: | :--------------------------: |
  | 顶点数据 | 以该顶点为弧头的第一个弧结点 | 以该顶点为弧尾的第一个弧结点 |

十字链表中，即容易找到$V_i$为尾的弧，也容易找到$V_i$为为头的弧，因而容易求的顶点的出度和入度。

#### 6.2.4 邻接多重表

邻接多重表是**无向图**的一种链式存储结构，结构如下：

- 边结点：

  |      ivex      |         ilink          |      jvex      |         jlink          |   (Info)   |
  | :------------: | :--------------------: | :------------: | :--------------------: | :--------: |
  | 依附的顶点编号 | 下一条依附ivex顶点的边 | 依附的顶点编号 | 下一条依附jvex顶点的边 | 边结点信息 |

- 顶点结点：

  |  data  |       firstedge        |
  | :----: | :--------------------: |
  | 数据域 | 第一条依附于该顶点的边 |

同一条边在邻接多重表中只有一个结点，而在邻接表中有两个结点。

#### 6.2.5 图的基本操作

- Adjacent(G,x,y)
- Neighbors(G,x)
- InsertVertex(G,x)
- DeleteVertex(G,x)
- AddEdge(G,x,y)
- RemoveEdge(G,x,y)
- FirstNeighbor(G,x)
- NextNeighbor(G,x,y)
- Get_edge_value(G,x,y)
- Set_edge_value(G,x,y,v)
